(window.webpackJsonp=window.webpackJsonp||[]).push([[61],{476:function(t,r,a){"use strict";a.r(r);var s=a(2),i=Object(s.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("hr"),t._v(" "),r("h1",{attrs:{id:"一、概念"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一、概念"}},[t._v("#")]),t._v(" 一、概念")]),t._v(" "),r("p",[t._v("前面我们已经看到了如何处理任务不丢失的情况，即消息应答和失败重新入队机制。但是如何保障当RabbitMQ服务停掉以后消息生产者发送过来的消息不丢失。需要做两件事：将队列和消息都标记为持久化。")]),t._v(" "),r("h1",{attrs:{id:"二、队列持久化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二、队列持久化"}},[t._v("#")]),t._v(" 二、队列持久化")]),t._v(" "),r("p",[t._v("之前创建的队列都是非持久化的，rabbitmq如果重启的话，该队列就会被删除掉，如果要队列实现持久化 需要在声明队列的时候把durable参数设置为 true（持久化）。"),r("br"),r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/rabbitmq-26.png",alt:"image.png"}}),r("br"),t._v("但是需要注意的就是如果之前声明的这个队列不是持久化的，需要把原先队列先删除，或者重新创建一个不同名的持久化队列，不然就会出现错误。"),r("br"),r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/rabbitmq-27.png",alt:"image.png"}}),r("br"),t._v("以下为控制台中持久化与非持久化队列的UI显示区：蓝色的大写字母D表示该队列是持久化的。"),r("br"),r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/rabbitmq-28.png",alt:"image.png"}}),r("br"),t._v("这个时候即使重启rabbitmq队列也依然存在。")]),t._v(" "),r("h1",{attrs:{id:"三、消息持久化"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三、消息持久化"}},[t._v("#")]),t._v(" 三、消息持久化")]),t._v(" "),r("p",[t._v("要想让消息实现持久化需要在消息生产者修改代码，添加MessageProperties.PERSISTENT_TEXT_PLAIN这个属性。"),r("br"),r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/rabbitmq-29.png",alt:"image.png"}}),r("br"),t._v("当设置为消息持久化后，消息不仅会保存在内存，还会持久化一份到磁盘中，即使故障重启，消息还在。"),r("br"),t._v("但是这种情况并不能保证数据一定不会丢失，假如一条消息刚准备存储到磁盘的时候，还没存储完，消息并未真正完全写入磁盘，出现了故障，仍然有可能会丢失消息。保障数据安全性还需要结合发布确认机制共同实现。")])])}),[],!1,null,null,null);r.default=i.exports}}]);