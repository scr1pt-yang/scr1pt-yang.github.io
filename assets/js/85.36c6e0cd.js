(window.webpackJsonp=window.webpackJsonp||[]).push([[85],{500:function(s,e,t){"use strict";t.r(e);var a=t(2),r=Object(a.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("hr"),s._v(" "),e("p",[s._v("为了避免 Redis 的单点故障问题，我们可以搭建一个Redis 集群，将数据备份到集群中的其它节点上。若一个 Redis 节点宕机，则由集群中的其它节点顶上。"),e("br"),s._v("Redis 的主从集群是一个“一主多从”的读写分离集群。集群中的 Master 节点负责处理客户端的读写请求，而 Slave 节点仅能处理客户端的读请求。之所以要将集群搭建为读写分离模式，主要原因是，对于数据库集群，写操作压力一般都较小，压力大多数来自于读操作请求。所以，只有一个节点负责处理写操作请求即可。")]),s._v(" "),e("h1",{attrs:{id:"一、伪集群搭建与配置"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、伪集群搭建与配置"}},[s._v("#")]),s._v(" 一、伪集群搭建与配置")]),s._v(" "),e("p",[s._v("在采用单线程 IO 模型时，为了提高处理器的利用率，一般会在一个主机中安装多台Redis，构建一个 Redis 主从伪集群。下面要搭建的读写分离伪集群包含一个Master 与两个 Slave。它们的端口号分别是：6380、 6381、6382。")]),s._v(" "),e("h2",{attrs:{id:"_1、复制redis-conf"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、复制redis-conf"}},[s._v("#")]),s._v(" 1、复制redis.conf")]),s._v(" "),e("p",[s._v("在 redis 安装目录中使用mkdir创建一个目录，名称随意。这里命名为 cluster。然后将 redis.conf文件复制到cluster 目录中。该文件后面会被其它配置文件包含，所以该文件中需要设置每个 Redis 节点相同的公共的属性。"),e("br"),e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-140.png",alt:"image.png"}})]),s._v(" "),e("h2",{attrs:{id:"_2、修改redis-conf"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、修改redis-conf"}},[s._v("#")]),s._v(" 2、修改redis.conf")]),s._v(" "),e("p",[s._v("在 redis.conf 中做如下几项修改：")]),s._v(" "),e("h3",{attrs:{id:"_1-masterauth"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-masterauth"}},[s._v("#")]),s._v(" 1.masterauth")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-141.png",alt:"image.png"}}),e("br"),s._v("因为要搭建主从集群，且每个主机都有可能会是 Master，所以最好不要设置密码验证属性requirepass。如果真需要设置，一定要每个主机的密码都设置为相同的。此时每个配置文件中都要设置两个完全相同的属性：requirepass 与 masterauth。其中 requirepass 用于指定当前主机的访问密码，而 masterauth 用于指定当前 slave 访问 master 时向 master 提交的访问密码，用于让 master 验证slave身份是否合法。")]),s._v(" "),e("div",{staticClass:"custom-block danger"},[e("p",{staticClass:"title"}),e("p",[s._v("如果都不设置密码，那么当Master角色变换的时候则不会出现验证差错的情况，如果设置了密码，一定要让这些节点的密码都一致，否则在Master角色变换的时候，会出现节点身份验证失败的情况。")])]),e("h3",{attrs:{id:"_2-repl-disable-tcp-nodelay"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-repl-disable-tcp-nodelay"}},[s._v("#")]),s._v(" 2.repl-disable-tcp-nodelay")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-142.png",alt:"image.png"}}),e("br"),s._v("该属性用于设置是否禁用TCP 特性 tcp-nodelay。设置为 yes 则禁用 tcp-nodelay，此时 master 与slave 间的通信会产生延迟，但使用的 TCP 包数量会较少，占用的网络带宽会较小。相反，如果设置为 no，则网络延迟会变小，但使用的 TCP 包数量会较多，相应占用的网络带宽会大。")]),s._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"title"}),e("p",[s._v("tcp-nodelay：为了充分复用网络带宽，TCP 总是希望发送尽可能大的数据块。为了达到该目的，TCP 中使用了一个名为 Nagle 的算法。\nNagle 算法的工作原理是，网络在接收到要发送的数据后，并不直接发送，而是等待着数据量足够大（由 TCP 网络特性决定）时再一次性发送出去。这样，网络上传输的有效数据比例就得到了大大提升，无效数据传递量极大减少，于是就节省了网络带宽，缓解了网络压力。但是这样会产生延迟。\ntcp-nodelay 则是 TCP 协议中 Nagle 算法的开头。")])]),e("p",[s._v("在Redis的主从复制过程中，默认情况下，repl-disable-tcp-nodelay被设置为no（即启用TCP_NODELAY）。这意味着数据会尽快通过TCP连接进行传输，以减少延迟。这对于实时性要求较高的主从复制场景可能是有益的。"),e("br"),s._v("然而，在某些情况下，如果网络环境不稳定或带宽有限，启用TCP_NODELAY可能会导致网络拥塞和传输效率降低。在这种情况下，可以将repl-disable-tcp-nodelay设置为yes，以禁用TCP_NODELAY选项。这样做会增加一定的延迟，但可以提高网络吞吐量，减少拥塞情况。")]),s._v(" "),e("h2",{attrs:{id:"_3、新建redis6380-conf"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、新建redis6380-conf"}},[s._v("#")]),s._v(" 3、新建redis6380.conf")]),s._v(" "),e("p",[s._v("新建一个redis 配置文件redis6380.conf，该配置文件中的 Redis 端口号为 6380。"),e("br"),e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-143.png",alt:"image.png"}})]),s._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"title"},[s._v("ChatGPT：")]),e("ol",[e("li",[e("code",[s._v("include redis.conf")]),s._v("：这个指令告诉Redis去包含一个名为redis.conf的配置文件。这样做可以将一些通用的配置项放在redis.conf中，然后在不同的实例配置文件中通过include指令来引入，以避免重复配置相同的内容。")]),s._v(" "),e("li",[e("code",[s._v("pidfile /var/run/redis 6380.pid")]),s._v("：这个配置指定了Redis服务器进程的PID文件路径和文件名。PID文件用于存储Redis服务器进程的进程ID，通常用于管理和监控Redis进程。")]),s._v(" "),e("li",[e("code",[s._v("port 6380")]),s._v("：这个配置指定了Redis服务器的监听端口号。在这里，Redis服务器被配置为监听6380端口，这意味着客户端可以通过该端口连接到Redis服务器。")]),s._v(" "),e("li",[e("code",[s._v("dbfilename dump6380.rdb")]),s._v("：这个配置指定了持久化存储数据的RDB文件的文件名。在这里，Redis被配置为将持久化数据保存到名为dump6380.rdb的文件中。")]),s._v(" "),e("li",[e("code",[s._v("appendfilename appendonly6380.aof")]),s._v("：这个配置指定了AOF持久化模式下的日志文件名。AOF（Append-Only File）持久化模式会将每个写命令追加到一个日志文件中，这里配置的文件名为appendonly6380.aof。")]),s._v(" "),e("li",[e("code",[s._v("replica-priority 90")]),s._v("：这个配置指定了Redis复制(replication)的优先级。当Redis服务器作为从服务器(replica)进行复制时，优先级用于决定它是否可能被提升为主服务器(master)。在这里，设置为90表示具有较高的复制优先级。")]),s._v(" "),e("li",[e("code",[s._v("logfile access6380.log")]),s._v("：这个配置指定了Redis服务器的访问日志文件的文件名。Redis会将访问日志写入到access6380.log文件中，其中记录了服务器接收到的命令请求等信息。")])])]),e("h2",{attrs:{id:"_4、在复制两个conf文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4、在复制两个conf文件"}},[s._v("#")]),s._v(" 4、在复制两个conf文件")]),s._v(" "),e("p",[s._v("再使用 redis6380.conf 复制出两个 conf 文件：redis6381.conf 与redis6382.conf。然后修改其中的内容。"),e("br"),e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-144.png",alt:"image.png"}}),e("br"),s._v("修改 redis6381.conf 的内容如下："),e("br"),e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-145.png",alt:"image.png"}}),e("br"),s._v("修改 redis6382.conf 的内容如下："),e("br"),e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-146.png",alt:"image.png"}})]),s._v(" "),e("h2",{attrs:{id:"_5、启动三台-redis"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5、启动三台-redis"}},[s._v("#")]),s._v(" 5、启动三台 Redis")]),s._v(" "),e("p",[s._v("分别使用 redis6380.conf、redis6381.conf 与 redis6382.conf 三个配置文件启动三台Redis。"),e("br"),e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-147.png",alt:"image.png"}})]),s._v(" "),e("h2",{attrs:{id:"_6、设置主从关系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6、设置主从关系"}},[s._v("#")]),s._v(" 6、设置主从关系")]),s._v(" "),e("p",[s._v("再打开三个会话框，分别使用客户端连接三台 Redis。然后通过 slaveof 命令，指定 6380 的 Redis 为 Master。"),e("br"),e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-148.png",alt:"image.png"}}),e("br"),e("code",[s._v("slaveof 127.0.0.1 6380")]),s._v(" 的含义是将当前 Redis 实例设置为从服务器，连接到本地127.0.0.1地址的Redis主服务器上，主服务器监听的端口号为6380。这样做可以让从服务器实时地复制主服务器的数据，以保持数据的一致性，并提高数据的可用性和可靠性。")]),s._v(" "),e("h2",{attrs:{id:"_7、查看状态信息"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7、查看状态信息"}},[s._v("#")]),s._v(" 7、查看状态信息")]),s._v(" "),e("p",[s._v("通过 info replication 命令可查看当前连接的Redis 的状态信息。"),e("br"),e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-149.png",alt:"image.png"}}),e("br"),s._v("通过上图可以看到redis6380有两个slave，分别是6381和6382，在6381和6382节点上可以看到master已指定为6380，连接状态为up。")]),s._v(" "),e("h1",{attrs:{id:"二、分级管理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、分级管理"}},[s._v("#")]),s._v(" 二、分级管理")]),s._v(" "),e("p",[s._v("若 Redis 主从集群中的 Slave 较多时，它们的数据同步过程会对 Master 形成较大的性能压力。此时可以对这些 Slave 进行分级管理。"),e("br"),e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-150.png",alt:"image.png"}}),e("br"),s._v("设置方式很简单，只需要让低级别 Slave 指定其 slaveof 的主机为其上一级 Slave 即可。不过，上一级Slave 的状态仍为 Slave，它是更上一级的 Slave。"),e("br"),s._v("例如，指定 6382 主机为 6381 主机的 Slave，而 6381 主机仍为真正的 Master 的 Slave。"),e("br"),e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-151.png",alt:"image.png"}}),e("br"),s._v("此时会发现，Master 的 Slave 只有 6381 一个主机。")]),s._v(" "),e("h1",{attrs:{id:"三、容灾冷处理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、容灾冷处理"}},[s._v("#")]),s._v(" 三、容灾冷处理")]),s._v(" "),e("p",[s._v("在 Master/Slave 的 Redis 集群中，若 Master 出现宕机怎么办呢？有两种处理方式，一种是通过手工角色调整，使Slave 晋升为 Master 的冷处理；一种是使用哨兵模式，实现 Redis集群的高可用HA，即热处理。"),e("br"),s._v("无论 Master 是否宕机，Slave 都可通过 slaveof no one 将自己由 Slave 晋升为 Master。如果其原本就有下一级的 Slave，那么，其就直接变为了这些 Slave 的真正的 Master 了。而原来的 Master 也会失去这个原来的 Slave。"),e("br"),e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-152.png",alt:"image.png"}})])])}),[],!1,null,null,null);e.default=r.exports}}]);