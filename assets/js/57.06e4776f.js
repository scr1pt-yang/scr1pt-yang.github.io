(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{480:function(t,e,a){"use strict";a.r(e);var i=a(2),n=Object(i.a)({},(function(){var t=this,e=t._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("hr"),t._v(" "),e("h1",{attrs:{id:"一、exchange概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、exchange概念"}},[t._v("#")]),t._v(" 一、Exchange概念")]),t._v(" "),e("p",[t._v("RabbitMQ 消息传递模型的核心思想是: 生产者生产的消息从"),e("strong",[t._v("不会直接发送到队列")]),t._v("。实际上，通常生产者甚至都不知道这些消息传递传递到了哪些队列中。"),e("br"),t._v("相反，生产者只能将消息发送到"),e("strong",[t._v("交换机 (exchange)")]),t._v("，交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将它们推入队列。交换机必须确切知道如何处理收到的消息，是应该把这些消息放到特定队列还是说把他们放到许多队列中还是说应该丢弃它们。这就得由交换机的类型来决定。"),e("br"),e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/rabbitmq-33.png",alt:"image.png"}})]),t._v(" "),e("h1",{attrs:{id:"二、交换机类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、交换机类型"}},[t._v("#")]),t._v(" 二、交换机类型")]),t._v(" "),e("p",[t._v("RabbitMQ 的交换机大致可分为以下四类：")]),t._v(" "),e("ul",[e("li",[t._v("Fanout：广播（扇出）：将消息交给所有绑定到交换机的队列。")]),t._v(" "),e("li",[t._v("Direct：直接（路由）：把消息交给符合指定routing key 的队列。")]),t._v(" "),e("li",[t._v("Topic：通配符（主题）：把消息交给符合routing pattern（路由模式） 的队列。")]),t._v(" "),e("li",[t._v("headers：标题：headers信息类型交换机，通过消息内容中的headers属性匹配队列。")])]),t._v(" "),e("p",[t._v("前文介绍了两种RabbitMQ的工作方式，分别是简单模式（hello world）和工作队列模式（work queue），这两种工作方式都是基于Direct直接交换机，也是RabbitMQ默认的交换机。后面会将剩余集中模式逐一展开介绍，而最后一种headers交换机性能较差，在实际中并不常用。")]),t._v(" "),e("h1",{attrs:{id:"三、无名交换机"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、无名交换机"}},[t._v("#")]),t._v(" 三、无名交换机")]),t._v(" "),e("p",[t._v("在之前的例子中，使用"),e("code",[t._v('channel.basicPublish("",QUEUE_NAME,null,message.getBytes());')]),t._v('进行消息发送，这里第一个参数就是指定交换机的类型，虽然使用了空字符串""，仍然能实现将消息发送到指定队列，实际上，这里使用的是RabbitMQ的默认直接交换机（Direct Exchange），消息能路由发送到队列中其实是由'),e("code",[t._v("routingKey(bindingkey)")]),t._v("绑定key指定的，这里由于第二个参数指定了队列的名称，因此默认的直接交换机Direct根据routingKey将消息发送到指定的队列。")]),t._v(" "),e("h1",{attrs:{id:"四、绑定-bindings"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#四、绑定-bindings"}},[t._v("#")]),t._v(" 四、绑定(bindings)")]),t._v(" "),e("p",[t._v("那么什么是binding呢，binding其实是exchange和queue之间的桥梁，它告诉我们exchange和那个队列进行了绑定关系。比如说下面这张图告诉我们的就是X与Q1和Q2进行了绑定。"),e("br"),e("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/rabbitmq-34.png",alt:"image.png"}}),e("br"),t._v("binding的对应关系如下：")]),t._v(" "),e("ul",[e("li",[t._v("一个交换机可以和多个队列绑定。")]),t._v(" "),e("li",[t._v("一个交换机可和一个队列建立多个绑定关系（routingKey不同）。")])]),t._v(" "),e("p",[t._v("研究完RabbitMQ的交换机基本原理，后面将继续介绍剩余的RabbitMQ工作模式，他们是分别基于不同类型的交换机来实现的，并且对应不同的用法。")])])}),[],!1,null,null,null);e.default=n.exports}}]);