(window.webpackJsonp=window.webpackJsonp||[]).push([[71],{485:function(s,r,a){"use strict";a.r(r);var t=a(2),e=Object(t.a)({},(function(){var s=this,r=s._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[r("hr"),s._v(" "),r("p",[s._v("RDB，Redis DataBase，是指将内存中某一时刻的数据快照全量写入到指定的 rdb 文件的持久化技术。RDB 持久化默认是开启的。当 Redis 启动时会自动读取RDB 快照文件，将数据从硬盘载入到内存，以恢复 Redis 关机前的数据库状态。")]),s._v(" "),r("h1",{attrs:{id:"一、持久化的执行"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#一、持久化的执行"}},[s._v("#")]),s._v(" 一、持久化的执行")]),s._v(" "),r("p",[s._v("RDB 持久化的执行有三种方式：手动 save 命令、手动 bgsave 命令，与自动条件触发。")]),s._v(" "),r("h2",{attrs:{id:"_1、手动save命令"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、手动save命令"}},[s._v("#")]),s._v(" 1、手动save命令")]),s._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-109.png",alt:"image.png"}}),r("br"),s._v("通过在 redis-cli 客户端中执行 save 命令可立即进行一次持久化保存。save 命令在执行期间会阻塞redis-server 进程，直至持久化过程完毕。而在redis-server 进程阻塞期间，Redis不能处理任何读写请求，无法对外提供服务。")]),s._v(" "),r("h2",{attrs:{id:"_2、手动bgsave命令"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、手动bgsave命令"}},[s._v("#")]),s._v(" 2、手动bgsave命令")]),s._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-110.png",alt:"image.png"}}),r("br"),s._v("通过在 redis-cli 客户端中执行 bgsave 命令可立即进行一次持久化保存。不同于 save 命令的是，正如该命令的名称一样，background save，后台运行 save。bgsave 命令会使服务器进程redis-server 生成一个子进程，由该子进程负责完成保存过程。在子进程进行保存过程中，不会阻塞redis-server 进程对客户端读写请求的处理。")]),s._v(" "),r("h2",{attrs:{id:"_3、自动条件触发"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3、自动条件触发"}},[s._v("#")]),s._v(" 3、自动条件触发")]),s._v(" "),r("p",[s._v("自动条件触发的本质仍是 bgsave 命令的执行。只不过是用户通过在配置文件中做相应的设置后，Redis 会根据设置信息自动调用 bgsave 命令执行。具体配置方式，后面有详解。")]),s._v(" "),r("h2",{attrs:{id:"_4、查看持久化时间"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4、查看持久化时间"}},[s._v("#")]),s._v(" 4、查看持久化时间")]),s._v(" "),r("p",[s._v("通过 lastsave 命令可以查看最近一次执行持久化的时间，其返回的是一个 Unix 时间戳。"),r("br"),r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-111.png",alt:"image.png"}})]),s._v(" "),r("h1",{attrs:{id:"二、rdb优化配置"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#二、rdb优化配置"}},[s._v("#")]),s._v(" 二、RDB优化配置")]),s._v(" "),r("p",[s._v("RDB 相关的配置在redis.conf 文件的 SNAPSHOTTING 部分。"),r("br"),r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-112.png",alt:"image.png"}})]),s._v(" "),r("h2",{attrs:{id:"_1、save"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、save"}},[s._v("#")]),s._v(" 1、save")]),s._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-113.png",alt:"image.png"}}),r("br"),s._v("该配置用于设置快照的自动保存触发条件，即 save point，保存点。该触发条件是在指定时间段内发生了指定次数的写操作。除非另有规定，默认情况下持久化条件为 save 3600 1"),r("br"),s._v("300 100 60 10000。其等价于以下三条："),r("br"),s._v("●  save 3600 1           #  在 3600 秒(1 小时)内发生 1 次写操作"),r("br"),s._v("●  save 300 100         #  在 300 秒(5 分钟)内发生 100 次写操作"),r("br"),s._v("●  save 60 10000       #  在 60 秒(1 分钟)内发生 1 万次写操作"),r("br"),s._v("如果不启用 RDB 持久化，只需设置 save 的参数为空串即可：save “”。")]),s._v(" "),r("h2",{attrs:{id:"_2、stop-write-on-bgsave-error"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、stop-write-on-bgsave-error"}},[s._v("#")]),s._v(" 2、stop-write-on-bgsave-error")]),s._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-114.png",alt:"image.png"}}),r("br"),s._v("默认情况下，如果 RDB 快照已启用（至少一个保存点），且最近的 bgsave 命令失败，Redis将停止接受写入。这样设置是为了让用户意识到数据没有正确地保存到磁盘上，否则很可能没有人会注意到，并会发生一些灾难。当然，如果 bgsave 命令后来可以正常工作了，Redis将自动允许再次写入。")]),s._v(" "),r("h2",{attrs:{id:"_3、rdbcompression"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3、rdbcompression"}},[s._v("#")]),s._v(" 3、rdbcompression")]),s._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-115.png",alt:"image.png"}}),r("br"),s._v("当进行持久化时启用 LZF 压缩字符串对象。虽然压缩 RDB 文件会消耗系统资源，降低性能，但可大幅降低文件的大小，方便保存到磁盘，加速主从集群中从节点的数据同步。")]),s._v(" "),r("h2",{attrs:{id:"_4、rdbchecksum"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4、rdbchecksum"}},[s._v("#")]),s._v(" 4、rdbchecksum")]),s._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-116.png",alt:"image.png"}}),r("br"),s._v("从RDB5 开始，RDB 文件的 CRC64 校验和就被放置在了文件末尾。这使格式更能抵抗 RDB文件的损坏，但在保存和加载 RDB 文件时，性能会受到影响（约 10%），因此可以设置为 no禁用校验和以获得最大性能。在禁用校验和的情况下创建的RDB 文件的校验和为零，这将告诉加载代码跳过校验检查。默认为 yes，开启了校验功能。")]),s._v(" "),r("h2",{attrs:{id:"_5、sanitize-dump-payload"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5、sanitize-dump-payload"}},[s._v("#")]),s._v(" 5、sanitize-dump-payload")]),s._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-117.png",alt:"image.png"}}),r("br"),s._v("该配置用于设置在加载RDB 文件或进行持久化时是否开启对 zipList、listPack 等数据的全面安全检测。该检测可以降低命令处理时发生系统崩溃的可能。其可设置的值有三种选择："),r("br"),s._v("●  no：不检测"),r("br"),s._v("●  yes：总是检测"),r("br"),s._v("●  clients：只有当客户端连接时检测。排除了加载 RDB 文件与进行持久化时的检测。"),r("br"),s._v("默认值本应该是clients，但其会影响Redis 集群的工作，所以默认值为 no，不检测。")]),s._v(" "),r("h2",{attrs:{id:"_6、dbfilename"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6、dbfilename"}},[s._v("#")]),s._v(" 6、dbfilename")]),s._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-118.png",alt:"image.png"}}),r("br"),s._v("指定RDB 文件的默认名称，默认为 dump.rdb。")]),s._v(" "),r("h2",{attrs:{id:"_7、rdb-del-sync-files"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7、rdb-del-sync-files"}},[s._v("#")]),s._v(" 7、rdb-del-sync-files")]),s._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-119.png",alt:"image.png"}}),r("br"),s._v("主从复制时，是否删除用于同步的从机上的RDB 文件。默认是 no，不删除。不过需要注意，只有当从机的 RDB 和 AOF 持久化功能都未开启时才生效。")]),s._v(" "),r("h2",{attrs:{id:"_8、dir"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_8、dir"}},[s._v("#")]),s._v(" 8、dir")]),s._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-120.png",alt:"image.png"}}),s._v("\n指定RDB 与 AOF 文件的生成目录。默认为 Redis 安装根目录。")]),s._v(" "),r("h1",{attrs:{id:"三、rdb文件结构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#三、rdb文件结构"}},[s._v("#")]),s._v(" 三、RDB文件结构")]),s._v(" "),r("p",[s._v("RDB 持久化文件 dump.rdb 整体上有五部分构成："),r("br"),r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-121.png",alt:"image.png"}})]),s._v(" "),r("h2",{attrs:{id:"_1、sof"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1、sof"}},[s._v("#")]),s._v(" 1、SOF")]),s._v(" "),r("p",[s._v("SOF 是一个常量，一个字符串REDIS，仅包含这五个字符，其长度为 5。用于标识RDB文件的开始，以便在加载RDB 文件时可以迅速判断出文件是否是RDB 文件。")]),s._v(" "),r("h2",{attrs:{id:"_2、rdb-version"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2、rdb-version"}},[s._v("#")]),s._v(" 2、rdb_version")]),s._v(" "),r("p",[s._v("这是一个整数，长度为 4 字节，表示 RDB 文件的版本号。")]),s._v(" "),r("h2",{attrs:{id:"_3、eof"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3、eof"}},[s._v("#")]),s._v(" 3、EOF")]),s._v(" "),r("p",[s._v("EOF 是一个常量，占 1 个字节，用于标识RDB 数据的结束，校验和的开始。")]),s._v(" "),r("h2",{attrs:{id:"_4、check-sum"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4、check-sum"}},[s._v("#")]),s._v(" 4、check_sum")]),s._v(" "),r("p",[s._v("校验和 check_sum 用于判断 RDB 文件中的内容是否出现数据异常。其采用的是 CRC 校验算法。"),r("br"),r("strong",[s._v("CRC 校验算法：")]),r("br"),s._v("在持久化时，先将 SOF、rdb_version 及内存数据库中的数据快照这三者的二进制数据拼接起来，形成一个二进制数（假设称为数 a），然后再使用这个 a 除以校验和 check_sum，此时可获取到一个余数b，然后再将这个b 拼接到 a 的后面，形成 databases。"),r("br"),s._v("在加载时，需要先使用 check_sum 对RDB 文件进行数据损坏验证。验证过程：只需将RDB 文件中除EOF 与 check_sum 外的数据除以check_sum。只要除得的余数不是 0，就说明文件发生损坏。当然，如果余数是 0，也不能肯定文件没有损坏。"),r("br"),s._v("这种验证算法，是数据损坏校验，而不是数据没有损坏的校验。")]),s._v(" "),r("h2",{attrs:{id:"_5、databases"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5、databases"}},[s._v("#")]),s._v(" 5、databases")]),s._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-122.png",alt:"image.png"}}),r("br"),s._v("databases 部分是 RDB 文件中最重要的数据部分，其可以包含任意多个非空数据库。而每个 database 又是由三部分构成："),r("br"),s._v("●  SODB：是一个常量，占 1 个字节，用于标识一个数据库的开始。"),r("br"),s._v("●  db_number：数据库编号。"),r("br"),s._v("●  key_value_pairs：当前数据库中的键值对数据。"),r("br"),r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-123.png",alt:"image.png"}}),r("br"),s._v("每个 key_value_pairs 又由很多个用于描述键值对的数据构成。"),r("br"),s._v("●  VALUE_TYPE：是一个常量，占 1 个字节，用于标识该键值对中 value 的类型。"),r("br"),s._v("●  EXPIRETIME_UNIT：是一个常量，占 1 个字节，用于标识过期时间的单位是秒还是毫秒。"),r("br"),s._v("●  time：当前 key-value 的过期时间。")]),s._v(" "),r("h1",{attrs:{id:"四、rdb持久化过程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#四、rdb持久化过程"}},[s._v("#")]),s._v(" 四、RDB持久化过程")]),s._v(" "),r("p",[r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-124.png",alt:"image.png"}}),r("br"),s._v("       对于 Redis 默认的RDB 持久化，在进行 bgsave 持久化时，redis-server 进程会 fork 出一个 bgsave 子进程，由该子进程以异步方式负责完成持久化。而在持久化过程中，redis-server进程不会阻塞，其会继续接收并处理用户的读写请求。"),r("br"),s._v("       bgsave 子进程的详细工作原理如下："),r("br"),s._v("       由于子进程可以继承父进程的所有资源，且父进程不能拒绝子进程的继承权。所以， bgsave 子进程有权读取到redis-server 进程写入到内存中的用户数据，使得将内存数据持久化到 dump.rdb 成为可能。"),r("br"),s._v("       bgsave 子进程在持久化时首先会将内存中的全量数据 copy 到磁盘中的一个RDB 临时文件，copy 结束后，再将该文件rename 为 dump.rdb，替换掉原来的同名文件。"),r("br"),r("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/redis-125.png",alt:"image.png"}}),r("br"),s._v("不过，在进行持久化过程中，如果 redis-server 进程接收到了用户写请求，则系统会将内存中发生数据修改的物理块 copy 出一个副本。等内存中的全量数据 copy 结束后，会再将副本中的数据copy 到RDB 临时文件。这个副本的生成是由于 Linux 系统的写时复制技术（Copy-On-Write）实现的。")]),s._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"title"}),r("p",[s._v("写时复制技术是 Linux 系统的一种进程管理技术。"),r("br"),s._v("原本在 Unix 系统中，当一个主进程通过 fork()系统调用创建子进程后，内核进程会复制主进程的整个内存空间中的数据，然后分配给子进程。这种方式存在的问题有以下几点："),r("br"),s._v("●  这个过程非常耗时"),r("br"),s._v("●  这个过程降低了系统性能"),r("br"),s._v("●  如果主进程修改了其内存数据，子进程副本中的数据是没有修改的。即出现了数据冗余，而冗余数据最大的问题是数据一致性无法保证。"),r("br"),s._v("现代的 Linux 则采用了更为有效的方式："),r("strong",[s._v("写时复制")]),s._v("。子进程会继承父进程的所有资源，其中就包括主进程的内存空间。即子进程与父进程共享内存。只要内存被共享，那么该内存就是只读的（写保护的）。而写时复制则是在任何一方需要写入数据到共享内存时都会出现异常，此时内核进程就会将需要写入的数据 copy 出一个副本写入到另外一块非共享内存区域。")])])])}),[],!1,null,null,null);r.default=e.exports}}]);