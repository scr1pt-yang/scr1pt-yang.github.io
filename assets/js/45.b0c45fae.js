(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{457:function(t,s,r){"use strict";r.r(s);var a=r(2),n=Object(a.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("hr"),t._v(" "),s("h1",{attrs:{id:"一、核心概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、核心概念"}},[t._v("#")]),t._v(" 一、核心概念")]),t._v(" "),s("p",[t._v("Docker镜像是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。"),s("br"),t._v("只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。")]),t._v(" "),s("h2",{attrs:{id:"_1、分层的镜像"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、分层的镜像"}},[t._v("#")]),t._v(" 1、分层的镜像")]),t._v(" "),s("p",[t._v("以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载"),s("br"),s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/docker-43.png",alt:"image.png"}})]),t._v(" "),s("h2",{attrs:{id:"_2、unionfs-联合文件系统"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、unionfs-联合文件系统"}},[t._v("#")]),t._v(" 2、UnionFS（联合文件系统）")]),t._v(" "),s("p",[t._v("UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。"),s("br"),t._v("特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。")]),t._v(" "),s("h2",{attrs:{id:"_3、docker镜像加载原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、docker镜像加载原理"}},[t._v("#")]),t._v(" 3、Docker镜像加载原理")]),t._v(" "),s("p",[t._v("docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。"),s("br"),t._v("bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是引导文件系统bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。"),s("br"),t._v("rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。 "),s("br"),s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/docker-44.png",alt:""}}),s("br"),t._v("平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？"),s("br"),s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/docker-45.png",alt:""}}),s("br"),t._v("对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。")]),t._v(" "),s("h2",{attrs:{id:"_4、为什么采用分层结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4、为什么采用分层结构"}},[t._v("#")]),t._v(" 4、为什么采用分层结构")]),t._v(" "),s("p",[t._v("镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。"),s("br"),t._v("比如说有多个镜像都从相同的 base 镜像构建而来，那么 Docker Host 只需在磁盘上保存一份 base 镜像；"),s("br"),t._v("同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。")]),t._v(" "),s("h1",{attrs:{id:"二、重点理解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、重点理解"}},[t._v("#")]),t._v(" 二、重点理解")]),t._v(" "),s("p",[t._v("Docker镜像层都是只读的，容器层是可写的。当容器启动时，一个新的可写层被加载到镜像的顶部。 这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。"),s("br"),t._v("所有对容器的改动 - 无论添加、删除、还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。"),s("br"),s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/docker-46.png",alt:""}})]),t._v(" "),s("h1",{attrs:{id:"三、docker镜像的commit操作"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、docker镜像的commit操作"}},[t._v("#")]),t._v(" 三、Docker镜像的commit操作")]),t._v(" "),s("p",[t._v("docker commit 可以提交容器副本使之成为一个新的镜像。"),s("br"),t._v("命令格式："),s("code",[t._v('docker commit -m="提交的描述信息" -a="作者" 容器ID 要创建的目标镜像名:[标签名]')])]),t._v(" "),s("h2",{attrs:{id:"_1、案例演示ubuntu安装vim"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、案例演示ubuntu安装vim"}},[t._v("#")]),t._v(" 1、案例演示ubuntu安装vim")]),t._v(" "),s("p",[t._v("首先从Hub仓库上下载ubuntu镜像到本地并成功运行。"),s("br"),t._v("原始的默认Ubuntu镜像是不带着vim命令的。"),s("br"),s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/docker-47.png",alt:""}}),s("br"),t._v("我们在外网连通的情况下，安装vim，在容器内执行下面这两条命令。")]),t._v(" "),s("div",{staticClass:"language-bash line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-bash"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 先更新包管理工具")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("apt-get")]),t._v(" update\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 然后安装我们需要的vim")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("apt-get")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("install")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("vim")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/docker-48.png",alt:""}}),s("br"),s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/docker-49.png",alt:""}}),s("br"),t._v("安装完成以后，conmmit我们自己的新镜像。"),s("br"),s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/docker-50.png",alt:""}}),s("br"),s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/docker-51.png",alt:""}}),s("br"),t._v("此时我们就可以根据新镜像的信息启动容器"),s("br"),s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/docker-52.png",alt:""}}),s("br"),t._v("对比：官网是默认下载的Ubuntu没有vim命令，我们自己commit构建的镜像，新增加了vim功能，可以成功使用。")]),t._v(" "),s("h2",{attrs:{id:"_2、总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、总结"}},[t._v("#")]),t._v(" 2、总结")]),t._v(" "),s("p",[t._v("Docker中的镜像分层，支持通过扩展现有镜像，创建新的镜像。类似Java继承于一个Base基础类，自己再按需扩展。"),s("br"),t._v("新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。"),s("br"),s("img",{attrs:{src:"https://cdn.jsdelivr.net/gh/scr1pt-yang/mypichost@main/img/docker-53.png",alt:""}})])])}),[],!1,null,null,null);s.default=n.exports}}]);