(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{484:function(e,t,r){"use strict";r.r(t);var a=r(2),v=Object(a.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("hr"),e._v(" "),t("div",{staticClass:"custom-block tip"},[t("p",{staticClass:"title"}),t("p",[e._v("Redis 中存储的数据整体是一个 Map，其 key 为 String 类型，而value 则可以是String、 Hash 表、List、Set 等类型。")])]),t("h1",{attrs:{id:"一、keys"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、keys"}},[e._v("#")]),e._v(" 一、keys")]),e._v(" "),t("p",[e._v("●  格式："),t("code",[e._v("KEYS pattern")]),t("br"),e._v("●  功能：查找所有符合给定模式 pattern  的 key，pattern 为正则表达式。"),t("br"),e._v("●  说明：KEYS 的速度非常快，但在一个大的数据库中使用它可能会阻塞当前服务器的服务。所以生产环境中一般不使用该命令，而使用 scan 命令代替。")]),e._v(" "),t("h1",{attrs:{id:"二、exists"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、exists"}},[e._v("#")]),e._v(" 二、exists")]),e._v(" "),t("p",[e._v("●  格式："),t("code",[e._v("EXISTS key")]),t("br"),e._v("●  功能：检查给定 key  是否存在。"),t("br"),e._v("●  说明：若 key  存在，返回 1  ，否则返回 0  。")]),e._v(" "),t("h1",{attrs:{id:"三、del"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、del"}},[e._v("#")]),e._v(" 三、del")]),e._v(" "),t("p",[e._v("●  格式："),t("code",[e._v("DEL key [key ...]")]),t("br"),e._v("●  功能：删除给定的一个或多个 key  。不存在的 key  会被忽略。"),t("br"),e._v("●  说明：返回被删除 key  的数量。")]),e._v(" "),t("h1",{attrs:{id:"四、rename"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、rename"}},[e._v("#")]),e._v(" 四、rename")]),e._v(" "),t("p",[e._v("●  格式："),t("code",[e._v("RENAME key newkey")]),t("br"),e._v("●  功能：将 key  改名为 newkey。"),t("br"),e._v("●  说明：当 key  和 newkey  相同，或者 key  不存在时，返回一个错误。当 newkey  已经存在时， RENAME 命令将覆盖旧值。改名成功时提示 OK ，失败时候返回一个错误。")]),e._v(" "),t("h1",{attrs:{id:"五、move"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五、move"}},[e._v("#")]),e._v(" 五、move")]),e._v(" "),t("p",[e._v("●  格式："),t("code",[e._v("MOVE key db")]),t("br"),e._v("●  功能：将当前数据库的 key  移动到给定的数据库 db  当中。"),t("br"),e._v("●  说明：如果当前数据库(源数据库)和给定数据库(目标数据库)有相同名字的给定 key  ，或者 key  不存在于当前数据库，那么 MOVE  没有任何效果。移动成功返回 1，失败则返回 0 。")]),e._v(" "),t("h1",{attrs:{id:"六、type"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#六、type"}},[e._v("#")]),e._v(" 六、type")]),e._v(" "),t("p",[e._v("●  格式："),t("code",[e._v("TYPE key")]),t("br"),e._v("●  功能：返回 key  所储存的值的类型。"),t("br"),e._v("●  说明：返回值有以下六种："),t("br"),e._v(" ◆ none (key 不存在)"),t("br"),e._v(" ◆ string (字符串)"),t("br"),e._v(" ◆ list (列表)"),t("br"),e._v(" ◆ set (集合)"),t("br"),e._v(" ◆ zset (有序集)"),t("br"),e._v(" ◆ hash (哈希表)")]),e._v(" "),t("h1",{attrs:{id:"七、expire-与-pexpire"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#七、expire-与-pexpire"}},[e._v("#")]),e._v(" 七、expire 与 pexpire")]),e._v(" "),t("p",[e._v("●  格式："),t("code",[e._v("EXPIRE key seconds")]),t("br"),e._v("●  功能：为给定 key  设置生存时间。当 key  过期时(生存时间为 0)，它会被自动删除。 expire 的时间单位为秒，pexpire 的时间单位为毫秒。在 Redis 中，带有生存时间的 key被称为“易失的”(volatile)。"),t("br"),e._v("●  说明：生存时间设置成功返回 1。若 key  不存在时返回 0  。rename 操作不会改变 key的生存时间。")]),e._v(" "),t("h1",{attrs:{id:"八、ttl-与-pttl"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#八、ttl-与-pttl"}},[e._v("#")]),e._v(" 八、ttl 与 pttl")]),e._v(" "),t("p",[e._v("●  格式："),t("code",[e._v("TTL key")]),t("br"),e._v("●  功能：TTL, time to live，返回给定 key  的剩余生存时间。"),t("br"),e._v("●  说明：其返回值存在三种可能："),t("br"),e._v(" ◆ 当 key  不存在时，返回 -2  。"),t("br"),e._v(" ◆ 当 key  存在但没有设置剩余生存时间时，返回 -1  。"),t("br"),e._v(" ◆ 否则，返回 key  的剩余生存时间。ttl 命令返回的时间单位为秒，而 pttl 命令返回的时间单位为毫秒。")]),e._v(" "),t("h1",{attrs:{id:"九、persist"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#九、persist"}},[e._v("#")]),e._v(" 九、persist")]),e._v(" "),t("p",[e._v("●  格式："),t("code",[e._v("PERSIST key")]),t("br"),e._v("●  功能：去除给定 key  的生存时间，将这个 key  从“易失的”转换成“持久的”。"),t("br"),e._v("●  说明：当生存时间移除成功时，返回 1；若 key  不存在或 key  没有设置生存时间，则返回 0。")]),e._v(" "),t("h1",{attrs:{id:"十、randomkey"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#十、randomkey"}},[e._v("#")]),e._v(" 十、randomkey")]),e._v(" "),t("p",[e._v("●  格式："),t("code",[e._v("RANDOMKEY")]),t("br"),e._v("●  功能：从当前数据库中随机返回(不删除)一个 key。"),t("br"),e._v("●  说明：当数据库不为空时，返回一个 key。当数据库为空时，返回 nil。")]),e._v(" "),t("h1",{attrs:{id:"十一、scan"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#十一、scan"}},[e._v("#")]),e._v(" 十一、scan")]),e._v(" "),t("p",[e._v("●  格式："),t("code",[e._v("SCAN cursor [MATCH pattern] [COUNT count] [TYPE type]")]),t("br"),e._v("●  功能：用于迭代数据库中的数据库键。其各个选项的意义为："),t("br"),e._v(" ◆ cursor：本次迭代开始的游标。"),t("br"),e._v(" ◆ pattern  ：本次迭代要匹配的 key 的模式。"),t("br"),e._v(" ◆ count  ：本次迭代要从数据集里返回多少元素，默认值为 10  。"),t("br"),e._v(" ◆ type：本次迭代要返回的value 的类型，默认为所有类型。"),t("br"),e._v("        SCAN 命令是一个基于游标 cursor 的迭代器：SCAN 命令每次被调用之后，都会向用户返回返回一个包含两个元素的数组， 第一个元素是用于进行下一次迭代的新游标，而第二个元素则是一个数组，这个数组中包含了所有被迭代的元素。用户在下次迭代时需要使用这个新游标作为 SCAN 命令的游标参数，以此来延续之前的迭代过程。当 SCAN 命令的游标参数被设置为 0 时，服务器将开始一次新的迭代。如果新游标返回 0表示迭代已结束。"),t("br"),e._v("●  说明：使用间断的、负数、超出范围或者其他非正常的游标来执行增量式迭代不会造成服务器崩溃。"),t("br"),e._v("        当数据量很大时，count 的数量的指定可能会不起作用，Redis 会自动调整每次的遍历数目。由于 scan 命令每次执行都只会返回少量元素，所以该命令可以用于生产环境，而不会出现像 KEYS 命令带来的服务器阻塞问题。"),t("br"),e._v("        增量式迭代命令所使用的算法只保证在数据集的大小有界的情况下迭代才会停止，换句话说，如果被迭代数据集的大小不断地增长的话，增量式迭代命令可能永远也无法完成一次完整迭代。即当一个数据集不断地变大时，想要访问这个数据集中的所有元素就需要做越来越多的工作， 能否结束一个迭代取决于用户执行迭代的速度是否比数据集增长的速度更快。"),t("br"),e._v("●  相关命令：另外还有 3 个 scan 命令用于对三种类型的 value 进行遍历。"),t("br"),e._v(" ◆ hscan：属于 Hash 型 Value 操作命令集合，用于遍历当前 db 中指定 Hash 表的所有 field-value 对。"),t("br"),e._v(" ◆ sscan：属于 Set 型Value 操作命令集合，用于遍历当前 db 中指定 set 集合的所有元素"),t("br"),e._v(" ◆ zscan：属于 ZSet 型 Value 操作命令集合，用于遍历当前 db 中指定有序集合的所有元素（数值与元素值）")])])}),[],!1,null,null,null);t.default=v.exports}}]);